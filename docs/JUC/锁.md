# Java中的各种锁

## 乐观锁和悲观锁

### 悲观锁

认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会**先加锁**，确保数据不会被别的线程修改。

- 适合写操作多的情况
- 先加锁，然后再操作数据

`synchronized` 关键字和 `Lock` 的实现类**都是悲观锁**

### 乐观锁

认为自己使用数据的时候没别的线程来修改数据，不用加锁

在Java中是通过使用无锁编程来实现，只是在更新数据的时候去判断，之前有没有别的线程更新了这个数据。

- 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。

- 如果这个数据已经被其它线程更新，则根据不同的实现方式执行不同的操作，比如放弃修改、重试抢锁等等

判断规则：

- 版本号机制Version（只要修改了数据，版本号就会加1）
- 最常采用的是CAS（compare and swap）算法，Java原子类中的递增操作就通过CAS自旋实现的。



适合读操作多的场景，因为不加锁，所以性能较高

## `synchronized` 锁



