# 酷家乐面经

## 一面（问了很多基础）

### volatile的特性？

可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入（靠原子性保障）。
能够防止相关指令重排序

### ReentrantLock和Synchronized的区别

都是可重入锁，它们都是加锁方式同步，而且都是阻塞式的同步，

| 比较方面       | SynChronized                                                 | ReentrantLock（实现了 Lock接口）                             |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原始构成       | 它是java语言的关键字，是原生语法层面的互斥，需要jvm实现      | API层面的互斥锁类                                            |
| 实现           | 通过JVM加锁解锁                                              | api层面的加锁解锁，需要手动释放锁。                          |
| 代码编写       | 采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用，更安全， | 而ReentrantLock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。需要lock()和unlock()方法配合try/finally语句块来完成， |
| 灵活性         | 锁的范围是整个方法或synchronized块部分                       | Lock因为是方法调用，可以跨方法，灵活性更大                   |
|                |                                                              |                                                              |
| 是否公平锁     | 非公平锁                                                     | 两者都可以，默认公平锁，构造器可以传入boolean值，true为公平锁，false为非公平锁， |
| 条件Condition  |                                                              | 通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能. |
| 提供的高级功能 |                                                              | 提供很多方法用来监听当前锁的信息，如：` getHoldCount()  getQueueLength() isFair() isHeldByCurrentThread() isLocked()` |
| 便利性         | Synchronized的使用比较方便简洁，由编译器去保证锁的加锁和释放 | 需要手工声明来加锁和释放锁，                                 |
| 适用情况       | 资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好 | ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。 |

### ReentrantLock的Condition的特性。

使用synchronized结合Object上的wait和notify方法可以实现线程间的等待通知机制。Condition同样可以实现这个功能，而且相比前者使用起来更清晰也更简单。前者是java底层级别的，后者是语言级别的，后者可控制性和扩展性更好。

**与wait/notify区别** 

​    1.Condition能够支持不响应中断，而通过使用Object方式不支

​    2.Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个 

​    3.Condition能够支持超时时间的设置，而Object不支持

### 如何实现一个生产者和消费者模型。



### 锁，乐观锁，悲观锁。

-   表级锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
-   行级锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；



悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能变动，一个事务拿到悲观锁后（可以理解为一个用户），其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。

mysql中最常用的引擎是Innodb，Innodb默认使用的是行锁。而行锁是基于索引的，因此要想加上行锁，在加锁时必须命中索引，否则将使用表锁。

乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。 但是，乐观不代表不负责，那么怎么去负责多个事务顺序对数据进行修改呢？乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本v1与数据中最新的版本v2相对比，如果v1=v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时version会加1，以此来表明数据已被变动。如果，v1不等于v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁是人为控制的。

### 多线程的实现方法。自定义多线程的七大参数和作用。

-   1.继承Thread类 重写run方法
-   2.实现Runnable接口 实现run方法
-   3.继承Callable接口 实现call方法 使用futureTask调用 (有返回值/可处理异常)

 ThreadPoolExecutor 的七大参数分析

-   1、corePoolSize:线程中的常驻核心线程数
-   2、maxmunPoolSize:线程池中能够容纳同时执行的最大线程数，此值必须大于1
-   3、keepAliveTime:多余空闲线程的存活时间。当前池中线程数量超过corePoolSize时&&当空闲时间达到keepAliveTime时，多余线程会被销毁直到剩下corePoolSize个线程为止（过剩策略）
-   4、unit:keepAliveTime的单位
-   5、workQueue:任务阻塞队列，被提交但尚未被执行的任务（不够策略）
-   6、threadFactory:表示生成线程池中工作线程的线程工厂，用于创建线程。一般默认即可
-   7、handler:拒绝策略，表示当任务阻塞队列满了，并且共工作线程大于等于线程池的最大线程数(maxmunPoolSize)时，如何拒绝请求执行的Runnable策略（饱满策略）

**ThreadPoolExecutor工作原理**

-   1、在创建了线程池后，开始等待请求。

-   2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：

     2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；

     2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；

     2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；

     2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。

-   3、当一个线程完成任务时，它会从队列中取下一个任务来执行。

-   4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：
    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。
    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。

### 多线程中，当线程数超过了阻塞队列的容量的情况。

### ThreadLocal的作用和应用场景。

使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改，这就是ThreadLocal类的作用

ThreadLocal里面有一个静态的ThreadLocalMap

在ThreadLocal里面源码set()，此时可以看到set()的源码就是首先获取当前线程，然后利用当前线程获取一个ThreadLocalMap的对象，然后如果ThreadLocalMap对象为空，则把当前ThreadLocal当成key，set()里面的参数当成value放到ThreadLocalMap集合里面，否则创建这个ThreadLocalMap对象，然后把当前ThreadLocal当成key，set()里面的参数当成value放到ThreadLocalMap集合里面

因为ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。

ThreadLocal类的应用场景
承载一些线程相关的数据
因为javaee三层架构里面，如果使用事务，要在service层里面进行开启事务（因为处理逻辑业务都是service层），然后又因为如果我们要使用事务，那么就必须保证执行sql语句的connection连接和开启事务的connection连接都要保持是同一个对象，所以我们要确保在service层和dao层的两个connection连接都是同一个，但是怎么保证connection连接对象都是同一个呢
一个是通过方法传参的方式进行数据的一层一层的传递，但是这样不好，因为你把架构分成三层的目的就是为了数据的处理和逻辑业务的处理分离开来(就是dao层处理数据，service层处理业务)，connection连接对象我们应该是在service层出现的，但是你却放到了dao层，这样数据的处理和逻辑业务的处理没有分离开来，javaee的三层开发就没有他的效果了，所以这一种方式的解决方法不好，所以我们就通过ThreadLocal的方式来存储这个connection对象，这样就能够保证在service层和dao层的数据保证一致了

### ArrayList和LinkedList的区别



### Synchronized的JDK1.8的优化，以及锁膨胀的过程。



### 计算机网络的http头部。



## 二面

1.问[项目]()（我做的是秒杀系统），问了些[项目]()中如何缓解数据库的压力。多级缓存。rocketmq在[项目]()中的使用。
2.Linux的一些命令，以及find命令的用法

3.[redis]()的五种数据结构，持久化。
4.问了论文的代码实现。

## 三面

1.  问了一个[项目]()相关的问题。如果你去超市购物。描述你在超市购物这个过程。有哪些实体集及其属性。
    大体有些，客户，超市，商品，支付，订单，订单明细。 
2.  问了些论文[项目]()，闲聊了一会。面试过程中没有什么压力，面试体现很好。



整体体验非常好，碰到不会的，会主动引导。真心推荐。 

 一面: 

  1.自我介绍 

  2.开始问[项目]()，降级策略怎么做的，如何分表的，如果防穿透的。 

  3.实习中踩到的坑。 

  4.Java的多态。 

  5.Java如何做lru，如何做到o1的复杂度的。 

使用双向链表，链表头为下一次需要剔除出缓存的数据，尾部为最近操作过的数据。（使得put为O(1)的时间复杂度）

-   LRU未满，直接尾部添加新元素
-   LRU满，删除头节点，尾部新增新数据

LRU,算法在操作缓存中常常被用到，由于其访问频繁，因此缩小LRU时间复杂度是非常必要的，好的LRU算法的实现能够很好的提高系统的稳定性
数据结构中map的访问速度非常快，时间复杂度为O(1),因此在缓存结构中，可以借助map结构，同时由于缓存需要容量满时需要删除操作，并且对于最近被访问的需要重新置于头部，在数据结构中链表能够很好的完成该操作，故缓存结构借助map加链表结构来降低时间复杂度，使得查询、删除、交换的时间复杂度都为O(1)，

具体设计如下，map中存放key -value对，查找时可以通过key快速定位到value,

value存放的是node节点，所有的value，都是双向链表中一个node，删除时直接移除
尾部节点即可，为简化操作，链表自带头节点head和尾节点tail



  6.索引结构，索引的好处，索引的不好的地方。 

  7.索引失效的情况。 

  8.[redis]()的数据结构，各种使用场景。 

  9.如何查看线上bug. 

  10.反问 

  


   二面:  

1.  自我介绍。  

2.  深问[项目]()，降级如何做的(降级后的数据，为什么不用消息队列，为什么不用[redis]()。什么时候触发降级)，为什么要分表，怎么分表的，分表后如何保证数据的均衡。如何做防穿透的，布隆过滤器的原理。线上监控的原理。数据库的性能，[redis]()的集群方式。说一下分布式锁怎么做的。Ps:其实这里还可以问数据库，[redis]()如何做容灾，如何做主从切换的。  

   3.ioc aop，如何实现ioc aop，如何实现声明式事物，threadlocal聊一下

   4.spring注解说一下。  

   5.spring如何解析和生成一个json对象。  

   6.spring mvc过程  

   7.springboot实现自动配置。  

   8.两个线程如何交替打印数字  

   9.信号量说一下。  

   10.说一下锁。  

   11.用不用git，linux常用命令  

   然后马上三面的。  

   


   三面:  

   1.自我介绍，[项目]()的一些简单的问题。  

   2.聊一下实习的收获，[职业规划]()。  

   3.聊一下实习[项目]()服务化升级过程，如何观察线上监控。  

  4.口述下如何做深搜，广搜，递归和非递归。 

  5.聊一下数学建模。 

  6.反问，了解下部门情况，流程情况。



作者：就是很菜
链接：https://www.nowcoder.com/discuss/533535?type=post&order=time&pos=&page=1&channel=-1&source_id=search_post_nctrack
来源：牛客网



1.先是介绍[项目]()，描述数据库，对我的配置服务生成的配置文件比较感兴趣，配置文件是怎样存储的，然后是怎样读取的我的配置文件。  

   2.介绍下java的常见的容器，说下hashmap的put操作，怎样解决hash冲突，  

   线程的安全问题，currentedHashmap怎样实现线程安全的问题，它与hashtable有什么区别，不都是线程安全的嘛。  

   3.线程池  

   用过线程池嘛，使用过什么样类型的线程池  

   线程池构造方法的传入的参数，最大线程，核心线程，队列大小，还有拒绝策略（这里没有答上来）。  

   自己实现过线程池没有，线程池的优势，为什么不能单独使用线程的方式呢。  

   4.mysql数据库  

   主要使用的索引有hash索引和b+索引，两者有什么相同和不同  

   b+数与别的[二叉树]()有什么区别，  

   引出了聚触索引和非聚触索引，这两者的区别，聚触索引不用回表，  

   还有什么样子的索引页不用回表操作，这个知道吗，是覆盖索引，具体进行解释。  

   那吗覆盖索引（A,B）我只用B索引进行数据的查找可以命中索引嘛？  

   最左前缀原则，那吗在联合索引中，我建立了联合索引，在数据库的  

   底层建立了几颗b+树，最左前缀原则实现的一个机制是什么样子的。  

   在底层查询数据的过程中是怎样来使用最左前缀原则查找数据的。  

   你们公司数据库的事务的隔离级别是什么，消除可重复度的底层机理，mvcc是什么，怎样实现多线程版本控制的。  

   5.[redis]()。  

   经常使用的数据类型是什么，  

   zset的底层是什么样的数据节构，跳跃表具体是什么。  

   [redis]()的缓存雪崩是什么样子的，怎样解决缓存雪崩。  

   6.jvm  

   java内存模型是什么样子的  

   java的内存分区，垃圾回收[算法]()。  

   新生代，老年代，永久代，怎样进行具体的垃圾回收。  

   常用到的垃圾回收器，新生代和年老代的垃圾回收器。  

   jvm的启动参数，一般设置的是多少。  

   G1和cms垃圾回收器的特点和区别。  

   gcRoot的可达性的定义（没有答上来）  

   7.spring框架。  

   bean是怎样管理的，bean的生命周期是什么，spring的常用注入方式有哪些。  

   使用过什么样子的设计模式，反射经常使用的两种类型，你自己用反射做过什么样的事情  

   对AOP的理解，解决了什么样子的问题。



作者：牛客351449550号
链接：https://www.nowcoder.com/discuss/529243?type=post&order=time&pos=&page=1&channel=-1&source_id=search_post_nctrack
来源：牛客网



一面（1.5h）：视频 

  自我介绍 

  问了一些简历相关的问题 

  出了一道设计题：火车票购票，分别有购票、退票、检票三个功能，一共五十张票，有文件A和文件B，文件A记录买票人信息，文件B记录检票人信息，模拟真实场景进行设计，需要考虑各种异常情况。（面试官最后说这个题有一个比较重要的考察点就是缓存和文件的读写顺序） 

  


  二面（1.2h）：视频 

  自我介绍 

  问了实习[项目]()相关的问题 

  gc[算法]() 

  arraylist和linkedlist区别 

  mysql的锁 

  代码题：设计一个循环队列，区别于arraylist的扩容机制，空间可重用。 

  智力题：给N根长度不同密度不均匀的绳子，从头到尾燃烧完需要1小时，需要多少根才能计时1小时15分 

  


  三面（1.2h）：电话 

  自我介绍 

  [项目]()详细介绍，问了一些细节 

  gc、jvm调优 

  nio，poll、epoll 

  系统设计：图书管理系统，每人一张卡，最多能借十本书，一本书最多能借30天，系统包括借书和还书，借书超过30天会计算罚金，罚金没还完无法继续借书。此外后面还加了一个预约功能。（基本就是从数据库表设计去回答了） 

  [算法题]()1：给一个数组A，其中每个数表示股票每天的价格，输出一次买入卖出的收益最大值。（[动态规划]()，两个数组temp1, temp2，temp1记录从第1天到第i天的收益最大值，temp2记录第1天到第i天的最低价格，temp1[i+1] = Math.max(temp1[i], A[i+1]-temp2[i])） 

  [算法题]()2：给n个有序数组，求一个区间[a, b]，确保每一个数组至少有一个值在区间内，并使区间最小。（先取出每个数组的最小值，用这n个数构建最小堆，然后每次去掉堆顶元素，将堆顶元素对应的那个数组的下一个元素加进堆里面，再调整成最小堆，重复至某个数组元素被清空为止） 

  


  其他可能还有一些问题不太记得了，因为面试比较多，记忆有点混乱，但是总的来说面试官给人的感觉还是挺好的。而且[酷家乐]()[面经]()好像挺少的，就整理了一下，供大家参考～



作者：offer球球了
链接：https://www.nowcoder.com/discuss/510961?type=post&order=time&pos=&page=1&channel=-1&source_id=search_post_nctrack
来源：牛客网



#### 1.[项目]()相关 

####  2.什么是线程安全 

####  3.如果多线程下购买商品加锁的话加在哪里？（我回答的是service层，后来面试官告诉我应该加在sql语句上） 

####  4.3的延申题，对mysql锁有没有了解？mysql如何加锁？ 

####  5.mysql的innodb下索引的数据结构是什么？B树和B+树区别在哪里？B+树的层数是如何计算的？ 

####  6.说下你知道的[排序]()[算法]()有哪些？ 

####  7.说下快速[排序]()的思想和过程？时间复杂度是多少？它的时间复杂度一直都是O(nlogn)吗？什么情况下它的时间复杂度是O(n^2)？ 

####  8.说下堆[排序]()的思想和过程？ 

####  9.反问



作者：悦悦的狗子
链接：https://www.nowcoder.com/discuss/529945?type=post&order=time&pos=&page=1&channel=-1&source_id=search_post_nctrack
来源：牛客网



[酷家乐]()一面（已过）：[项目]()介绍+Mysql（索引，事务，日志）+Java基础+JVM（运行时区域划分，类加载），还有其他的一些内容，面试官很好，一直引导我，也有一些不会的问题，给我解答，很贴心，是个技术大佬！！！

[酷家乐]()二面（已过）：[项目]()介绍+计算机网络（HTTP，TCP）+[算法]()（快排和堆排）+JVM（区域划分）+数据库（索引结构），面试官很幽默，交流非常愉快，回答的有一些错误问题都给我细心解答，然后我就记录下来，非常热情，感觉我太幸运了，遇到的面试官都非常好！！！

  [酷家乐]()三面(结果未知，面试官说需要小组讨论，许愿通过啊啊啊！) 

  自我介绍，用户态内核态，OSI模型，TCP与UDP区别，TCP可靠原因，线程安全集合，Java的IO模型（这个我不会，太伤了呜呜呜），数据库隔离级别，聚簇索引和非聚簇索引，主键乱序会有什么影响？（这个不太会），数据库分库分表框架（不会），Spring框架[源码]()（没看过，我太菜了），RPC框架（不会），binlog有几种模式？（好像是这个问题，我也不会）设计模式设计原则（不记得了），Redis内存管理（不会，我真的太菜了，要哭了）。



作者：敷衍21
链接：https://www.nowcoder.com/discuss/505025?type=post&order=time&pos=&page=1&channel=-1&source_id=search_post_nctrack
来源：牛客网



40min 

  \1. 自我介绍 

  2.计算机存储数据的格式 

  3.怼[项目]()，很细很细（30min）回答不好 

  4.悲观锁、乐观锁 

  5.hashmap和currentHashmap的区别 

  6.currentHashmap为什么保证线程安全？ 

  7.索引的类型？底层结构 

  8.聚簇索引和非聚簇索引、聚簇为什么快？ 

  9.jvm内存结构？哪些线程独有？ 

  12.synchronized的可重入 

  13bean对象的生命周期







