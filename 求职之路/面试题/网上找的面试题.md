# 网上找的面试题

[TOC]



# 计算机网络  

##   连不上网可能哪里有问题  



##   网络模型  

###   七层网络模型  

1. 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 

2. 数据链路层 

3. 网络层   IP 

4. 传输层   TCP、UDP 

5. 会话层 

6. 表示层   对底层命令和数据进行解释，   

7. 应用层   应用层协议：DNS、HTTP、SMTP等，用户在这一层与网络进行交互  

###   TCP/IP四层  

1. 网络接口层 

2. 网际层   IP 

3. 运输层   TCP、UDP 

4. 应用层   HTTP、SMTP、FTP等 
   

##   HTTP  

###   HTTP和HTTPS的区别  

- https需要到ca申请证书，因而需要一定费用  

- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议，成本较高  

- http的连接很简单，是无状态的，https协议是由ssl+http协议构建的可进行加密串苏，身份验证的网络协议  

- http用的端口是80，https用的端口是443  

###   HTTP请求报文的内容  

  请求行包括请求方法（GET、POST…），URL，HTTP协议版本  

  请求头。格式为，头部字段：值。常见头部字段有…  

  请求正文  

###   HTTP头部有哪些主要字段  

  Host：接受请求的服务器地址，可以是IP或者是域名  

  User-Agent：发送请求的应用名称  

  Connection：指定与连接相关的属性，例如（Keep_Alive，长连接）  

  Accept-Charset：通知服务器端可以发送的编码格式  

  Accept-Encoding：通知服务器端可以发送的数据压缩格式  

  Accept-Language：通知服务器端可以发送的语言  

###   HTTP响应报文  

  状态行：协议版本，状态码，状态码描述  

  响应头  

  响应正文  

###   HTTP响应头主要字段  

  Server：服务器应用软件的名称和版本  

  Content-Type：响应正文的类型  

  Content-Length：响应正文的长度  

  Content-Charset：响应正文所使用的编码  

  Content-Encoding：响应正文使用的数据压缩格式  

  Content-Language：响应正文使用的语言  

###   HTTP状态码  

  1xx 服务器收到请求，需要请求者继续执行操作  

  2xx ok，请求成功  

  3xx 重定向，资源已经重新分配  

  4xx 客户端请求错误，403 forbidden请求资源被拒绝，404 not found找不到请求资源  

  5xx 服务器错误，500 服务器故障，503 服务器超载或停机维护  



  200，请求成功  

  301，资源（网页等）被永久转移到其它URL  

  302，资源临时移动  

  403，forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求。请求资源被拒绝，通常原因是服务器上某些文件或目录设置了权限，客户端权限不够 

  404，not found，用户输入错误的链接，该链接指向的网页不存在。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 

  500，internal server error 服务器内部错误（比如浏览器代理除了问题，ip，端口不对等）该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。 

  502，Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应  

  503，服务器超载或停机维护  

  504，Gateway Timeout网关超时 服务器作为网关或代理，未及时从上游服务器接收请求。 

 

###   HTTP劫持  

  在正常的数据流中插入特定的网络数据报文，让客户端解释错误的数据，并以弹出新窗口的形式向使用者展示小广告或网页内容  

  步骤：  

- 在TCP连接中标识HTTP协议链接；  

- 改HTTP响应体；  

- 将篡改后的数据包抢先回发到用户，这样后面的数据包在到达后会被直接丢弃。而客户端显示改后的网页  

  防范：  

- 事前加密：HTTPS，防止明文传输被挟持，（但防不了DNS挟持）  

- 事中加密：拆分HTTP请求数据包，运营商的旁路设备没有完整的TCP/IP协议栈，不能标记，web服务器有完整的TCP/IP协议栈，能把接收到的数据包拼成完整的HTTP请求，不影响服务  

- 事后屏蔽：前端显示HTTP时对内容进行检测，在DOM结构发生变化时触发回调  

​    

  DNS劫持：通过劫持DNS服务器，获得某域名的解析记录控制权，修改此域名的解析结果。把原来对A域名的访问转入B域名，返回错误的查询结果。可能是一些产品的持续的推广  

  区别：DNS劫持倾向于持续性，访问一个界面时强行推送广告，HTTP劫持频率多变，劫持过程也非常快，一般多出现于网站小尾巴 

  HTTPS挟持：伪造证书来进行挟持….  

​    

###   跨域  

  跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。  

  同源：域名，协议，端口均相同  

  即浏览器只能执行相同协议、相同域名、相同端口下的网站脚本，执行的时候如果网站的脚本不属于现在这个界面，就不会执行  

###   HTTP请求响应中断原因 

  网断了，网络阻塞，请求超时，浏览器出问题，服务器出问题  

####   如何检查  

  检查网络，检查本地…  

###   HTTP有几种请求方式  

  HTTP1.0 定义了三种请求方法： GET, POST 和HEAD方法。  

  HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和CONNECT 方法。  

###   GET和POST的区别  

 GET的参数放在url中，返回服务器拿数据；

POST在request body里自带一个参数去服务器拿指定的数据；  

 因为GET的参数暴露在url上，所以安全性不能保证，也有长度的限制  

####   应用场景 

  GET用来查询数据，POST用来修改数据，以及其他更需要安全性的场景如密码  

##   DNS的查找过程（应用层）  

  用于将用户提供的主机名解析为ip地址  

0. 浏览器从接收到的url中抽取出域名地址，将域名传给DNS应用的客户端  

1. 检查浏览器缓存、本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射   

2. 如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射  

3. 如果没有，则向DNS服务器提出查询请求  

4. 服务器接收到查询时，查询本地配置区域资源，查到就返回结果  

5. 如果查不到，但服务器缓存了此网址映射关系，返回查找结果  

6. 如果没有缓存，就继续间请求转发至上一级DNS服务器进行查询。最终将解析结果依次返回本地DNS服务器，本地DNS服务器在返回给客户端，并把这个映射存到服务器的缓存中  

##   IP  

###   IP地址分类  

  A类：1字节（8位）网络号，3字节（24位）主机号。网络号第一位固定为0，剩下7位随便用。保留地址0（00000000）表示“本文网络”，127（01111111）表示本地环回软件测试  

  B类：2字节（16位）网络号，2字节（16位）主机号。网络号前两位固定为10，剩下16位随便用。保留地址  

  C类：3字节（24位）网络号，1字节（8位）主机号。前三位固定为110，剩下21位可用。  

  D类：  

  E类：  

  主机号全是0的IP地址表示是“本主机”所连接到的单个网络。  

  主机号全是1的IP地址表示是网络地址

​    

  A类地址的表示范围是：0.0.0.0-126.255.255.255，默认网络掩码为：255.0.0.0，A类地址分配给规模特别大的网络使用，  

  B类地址表示范围是：128.0.0.0-191.255.255.255，默认网络掩码为：255.255.0.0，B类地址分配给一般的中型网络  

  C类地址的表示范围是192.0.0.0-223.255.255.255，默认网络掩码是：255.255.255.0，C类地址分配给小型网络，如局域网  

  D类地址称为广播地址，共特殊协议向选定的节点发送信息使用。  

​    

###   ipv4和ipv6的转换。ipv4到ipv6的过渡手段  

  ipv4和ipv6的过渡是一个循序渐进的过程，在用户体验IPv6带来的好处的同时仍能与网络中其余的IPv4用户通信。  

  主流技术：

1. 双栈策略：（最直接方式）在IPv6结点中加入IPv4协议栈。这种具有双协议栈的结点称作“IPv6/v4结点”，这些结点可以使用IPv4与IPv4结点互通，也可以直接使用IPv6与IPv6结点互通。  

2. 隧道技术：（为解决局部纯IPv6网络与IPv4骨干隔离形成的孤岛问题，用隧道技术的方式解决）利用穿越现存IPv4互联网的隧道技术将孤岛连接起来，逐步扩大IPv6的实现范围。在隧道的入口处，路由器将IPv6的数组分组封装进入IPv4中，IPV4分组的源地址和目的地址分别是隧道入口和出口的IPV4地址。在隧道的出口处再将IPV6分组取出转发给目的节点。  

  隧道技术在实践中有四种具体形式：构造隧道、自动配置隧道、组播隧道以及6to4。  

3. 隧道代理TB，Tunnel Broker。（目的是简化隧道的配置，提供自动的配置手段），TB可以看作是一个虚拟的IPv6 ISP，它为已经连接到IPv4网络上的用户提供连接到IPv6网络的手段，而连接到IPv4网络上的用户就是TB的客户。  

4. 协议转换技术。其主要思想是在V6节点与V4节点的通信时需借助于中间的协议转换服务器，此协议转换服务器的主要功能是把网络层协议头进行V6/V4间的转换，以适应对端的协议类型。  

5. SOCKS64。  在客户端里引入SOCKS库，它处于应用层和socket之间，对应用层的socket API和DNS域名解析API进行替换。  另一种是SOCKS网关。  

6. 传输层中继   与SOCKS64的工作机理相似，只不过是在传输层中继器进行传输层的“协议翻译”  

7. 应用层代理网关（ALG）  类似。在应用层进行协议翻译。  

##   ARP协议  

  Address Resolution Protocol，即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址  

1. 查主机缓存里（的ARP列表里）有没有记录这个IP和MAC地址的对应  

2. 有就直接发送，没有就向本网段所有主机发送广播，发送自己的IP地址和MAC地址，询问谁是这个IP地址，这个地址的MAC地址是什么  

3. 网络中的其他主机收到之后对照被询问的地址和自己能不能对上，是的话就从数据包中提取源主机的IP和mac地址写入自己的ARP列表，并将自己的MAC地址写入响应包，回复源主机  

4. 源主机收到ARP响应包之后，就可以用这些信息发送数据  

  **为什么要用ARP协议**：OSI把网络分成7层，每层之间不直接交流，只有特定接口有交流。IP在第三层网络层，MAC地址工作在第二层数据链路层。协议发包时需要封装IP地址和MAC地址，但只知道IP，又不能跨层直接找，所以得用ARP协议的服务帮助获取目的节点的MAC地址  

##   浏览器中输入一个URL后，按下回车后发生了什么  

  URL，统一资源定位符，l简单点就是网址=ip或域名 + 端口号 + 资源位置 + 参数 + 锚点  

  1 . 输入一个网址之后，首先浏览器通过查询DNS，查找这个URL的IP地址，（通过层层向上级DNS服务器查找直到找到对应URL的IP地址）  

  2．得到目标服务器的IP地址及端口号（http 80端口，https 443端口），会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文  

  （1）应用层：客户端发送HTTP请求报文。  

  （2）传输层：（加入源端口、目的端口）建立连接。实际发送数据之前，三次握手客户端和服务器建立起一个TCP连接。  

  （3）网络层：（加入IP头）路由寻址。  

  （4）数据链路层：（加入frame头）传输数据。  

  （5）物理层：物理传输bit。  

  3．服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。  

  4．关闭连接，TCP四次挥手。  

  5．客户端解析HTTP响应报文，浏览器开始显示HTML  

###   网页卡顿原因  

- 网速慢、带宽不足、硬件配置低、内存被占满。  

- JS脚本过大，阻塞了页面的加载。  

- 网页资源过多、接受数据时间长、加载某个资源慢。  

- DNS解析速度。  

###   一般怎么检查  

  硬件问题：检查网线或者无限网卡有没有插好，有没有连上路由器，就是底层是不是联通状态；   

  软件问题：查看是否有对应的驱动，服务器好不好，DNS对不对，或者可能是代理没关  

###   当网页加载很慢的时候，应如何分析其原因并解决问题？  

- http请求次数太多 

- 资源过大，资源过多 

- JS脚本过大 

- 网速慢 

- … 

​    

###   给一个网址先解析什么后解析什么（域名解析顺序）？  

  域名分层：从右到左分别为顶级域名、二级域名…最左为主机名（服务器名）。比如[www.baidu.com的com](http://www.baidu.xn--comcom-rw6o/)为顶级域名，email.tsinghua.edu.cn中cn为顶级域名，为中国国家域名，edu为教育科研部门域名，email为服务器名。  

  域名解析时，优先查找匹配的子域名，如果子域名存在，则从子域名的配置文件查询解析结果，如果子域名不存在，就从上一级的配置文件查询结果  

​    

##   高并发  

  响应时间、吞吐量、并发用户数…  

  测试多用户同时访问，访问量的缓慢增加/迅速增加…  

  大量相同类型访问，大量不同类型的访问  

  服务器角度，能够承受多大的压力（？），客户端角度，数据能否成功得到需要的信息，响应时间怎么样  

  实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息 

  一方面保证数据不丢失、一方面保证性能 



##   TCP、UDP  

###   TCP连接三次握手的过程  

  初始状态客户端CLOSED，服务器LISTEN  

1. 客户端A向服务器B发送SYN数据包（SYN, x:0）请求连接。此时状态为SYN_SENT，表示客户端已发送SYN报文。  

2. 服务器B收到，发送SYN/ACK数据包（SYN/ACK, y:x+1）回应。此时服务器状态由LISTEN（服务器socket处于监听状态，可以接受连接）变为SYN_RECV，表示收到SYN报文  

3. 客户端A收到并发出确认ACK（ACK, x+1:y+1），连接成功。双方状态ESTABLISHED  

​    

###   TCP四次挥手的过程  

  初始状态双方ESTABLISHED  

1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。客户端FIN_WAIT_1。表示主动关闭连接，向对方发送了FIN，进入FIN_WAIT_1，等待对方的确认  

2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。客户端FIN_WAIT_2，表示半连接，而服务器可能还有数据要发，这边稍后关闭。服务器**CLOSE_WAIT**。  

3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。服务器LAST_ACK，等待对面的ACK报文  

4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。客户端进入**TIME_WAIT**，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。  

####   为何TIME_WAIT：  

  防止服务器在处于LAST_ACK状态下未收到ACK报文而重发FIN报文，这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。  

​    

###   TCP和UDP的特点  

  TCP面向连接，UDP无连接  

  TCP可靠，保证安全，UDP尽最大努力交付，不保证安全  

  TCP是点对点的，UDP可以一对一 一对多 多对多 多对一  

  TCP面向字节流，UDP无拥塞控制  

  TCP开销较大，UDP开销小  

​    

###   TCP、UDP的应用场景  

  UDP使用场景 DNS协议（因为用UDP快），看视频、发语音、QQ聊天、多媒体教室屏幕广播  

  TCP使用场景 HTTP协议，QQ传文件，邮件，登陆  

​    

###   TCP怎么实现可靠传输  

  确认和重传机制：建立连接、发送包时的确认，运输过程中校验失败、丢包或延时发送端重传  

  数据排序：把数据分成很多包，按顺序进行传输  

  流量控制：滑动窗口和计时器  

  拥塞控制：慢启动、拥塞避免、快速重传、快速恢复  

​    

###   流量控制  

  作用于接收方，控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。  

  由滑动窗口实现  

####   滑动窗口  

  TCP进行流量控制的方式，接收方通过告诉对方自己的窗口大小，从而控制发送方的发送速度，以防止由于发送方发送速度过快而导致自己被淹没的现象  

####   计时器  

  发送端收到为0的窗口后开启一个计时器，时间到了之后发包询问现在的滑动窗口，防止死锁（接收端发回的不为0的窗口的包丢失，双方相互等待）  

###   拥塞控制  

  作用于网络，防止过多的数据注入到网络中，避免出现网络负载过大的情况。  

  拥塞：对网络中某一资源的需求超过了该资源所能提供的可用部分，影响到网络性能  

  拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。  

####   拥塞窗口  

  发送方使用的流量控制，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。  

####   慢启动和拥塞避免  

  慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。  

  拥塞窗口一开始设为1 ，每收到一次确认，就让拥塞窗口变为原来的两倍，当窗口值为16时（慢启动门限），改为加法增大，每次+1，直到网络拥塞。拥塞时让新的慢启动门限设为拥塞时的一半，并把拥塞窗口置为1，再让他重复，这时一瞬间会将网络数据量大量降低。  

  拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。  

####   快重传和快恢复  

  快重传：接收方每收到一个失序的报文段（收完2后就收到了4说明3丢了）就立即发出包2的重复确认，这样可以让发送方尽早知道丢包了。  

  发送端连续收到三个重复确认就立即重传3  

  快恢复：发送方收到3个连续确认时，把慢开始门限减半，把拥塞窗口的值置为慢开始门限的一半，实行拥塞避免算法，每次确认收到后+1  

​    

#   操作系统  

  操作系统（Operating System，OS）： 

  控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。 

  为用户提供服务，使用户能在计算机上使用各种应用程序来操作计算机资源 

  是用户和计算机硬件系统之间的接口 




  处理机： 

  计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。包括中央处理器、主存储器、I/O接口，处理器+外围设备（鼠标键盘之类）构成完整的操作系统 

  程序是描述处理机完成某项任务的指令序列。 

  指令则是处理机能直接解释、执行的信息单位。 

 

  中央处理器（CPU，Central Processing Unit）： 

  是一块超大规模的集成电路，是一台计算机的运算核心和控制核心。它的功能主要是解释计算机指令以及处理计算机软件中的数据。 




  内核： 

  操作系统的最基本部分、核心，决定一个程序在什么时候对某部分硬件操作多长时间 

  提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性 



##   操作系统的四个特性 

  并发：同一段时间内多个程序执行（与并行区分，并行指的是同一时刻有多个事件，多处理器系统可以使程序并行执行） 

  共享：系统中的资源可以被内存中多个并发执行的进线程共同使用 

  虚拟：通过分时复用（如分时系统）以及空分复用（如虚拟内存）技术把一个物理实体虚拟为多个 

  异步：系统进程用一种走走停停的方式执行，（并不是一下子走完），进程什么时候以怎样的速度向前推进是不可预知的 



##   操作系统的目标和功能 

  处理机管理： 

  处理机的运行以进程（或线程）为基本单位，对处理机的管理可归结为对进程的管理。 

  管理进程的资源共享：进程控制、进程同步、进程通信、死锁处理、处理机调度 

  存储器管理： 

  给多道程序的运行提供良好环境，方便用户使用+提高内存利用率 

  内存分配、地址映射、内存保护与共享、内存扩充 

  文件管理： 

  计算机中的信息以文件形式存在。 

  文件存储空间管理、目录管理、文件读写管理和保护 

  设备管理： 

  完成用户的I/O请求，方便用户使用各种设备，并提高设备利用率 

  缓冲管理、设备分配、设备处理、虚拟设备 



##   线程和进程  

  进程是操作系统进行资源分配和调度的最小单位，多个进程之间相互独立，如果一个进程崩溃，不会影响其他进程；  

  线程是CPU进行分配和调度的最小单位（或者说是进程的最小单位，进程的一部分），一个进程下可以有很多个线程共享该进程的所有资源，如果一个线程崩溃，整个进程就会崩溃。  

###   进程和线程的区别  

  进程是操作系统进行资源分配和调度的最小单位，每个进程有自己的一部分独立的资源，如果一个进程崩溃，不会影响其他进程；线程是CPU进行分配和调度的最小单位，一个进程下可以有很多个线程共享该进程的所有资源，如果一个线程崩溃，整个进程就会崩溃。  

  线程一般是共享资源，在创建、或是进行调度的时候开销比进程小很多，通信同步也比较方便  

  通信方面进程间通讯需要同步或互斥手段的辅助，来保证数据的一致性，线程间可以直接读/写进程数据段（如全局变量）来进行通信。  

###   简述多进程和多线程  

###   线程间通讯和进程间通讯的方法  

  **线程间：互斥锁、信号量、临界区…**  

  互斥量（全局变量）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。  

  信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。  

  临界区：是一个访问共用资源的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待，有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用。  

  **进程间：共享内存、信号量、管道、消息队列…**  

  共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。读写操作时需要用同步互斥的工具，保证在一个进程对这段内存进行访问的时候其他进程不能同时来  

  信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。  

  管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程。Pipe（管道），FIFO（有名管道）。调用管道，在内核里开辟一块缓冲区（一个共享文件）来进行进程间通信，有一个读端和一个写端（单向通信）  

  消息队列是消息的链表，存放在内核中并由消息队列标识符标识。  

###   进程同步  

  目的：对多个相关进程在执行顺序上进行协调，使并发执行的进程可以有效的共享资源和相互合作，保证程序执行的可再现性。  

​    

###   进程死锁 

  多个并发的进程中，如果每个进程都持有某种资源由等待其他进程释放它现在保持的资源，这些资源都只允许一个进程占用，结果两个进程都不能继续执行，也不会释放自己占有的资源，所以这种双方循环等待的现象回无限期持续，发生死锁。 

  **原因**

  互斥：资源不能共享，只能一个进程用 

  占用并等待：已经得到资源的进程可以再次申请新的资源 

  不可剥夺：已经分配的资源不能从相应进程中强制剥夺 

  循环等待：系统中若干进程形成环路，环路中的每个进程都在等待相邻进程正占用的资源 

  **死锁处理**  

  预防：破环四个原因中的一个或多个，但会影响到资源利用率及吞吐量 

  避免：在资源的动态分配中防止系统进入不安全状态 

  检测：死锁发生后，用一定的算法进行检测，并确定相关死锁相关的资源和进程，采取方法清楚死锁。 

  解除：对死锁相关进程，通过撤销或挂起的方式，释放一些资源 



###   处理机调度  

###   常用的调度算法 

  先来先服务调度：按进程到达的先后顺序依次调度 

  短作业优先调度：选择队列中估计时间较短的先进行处理 

  优先权调度：为不同队列设不同的优先级，等待时间长的适当提高优先级 

  时间片轮转：按进程到达的先后顺序放入队列，给队首进程分配CPU时间片，用完后计时器发出中断，暂停当前进程并将其放到队伍尾部，循环。 

###   线程状态（5） 

  创建：new Thread(r)创建，有了相应的内存空间和其他资源，但还未开始执行 

  就绪：start()方法启动，进入线程队列排队，等待CPU服务 

  运行：获得处理器资源 

  阻塞：需要进行耗时的输入输出操作时，要等阻塞清除才能进入队列排队 

  终止：stop()、destory()或run()结束后，不在具有继续运行的能力 

###   进程三态的转化（也有说5态的，和线程差不多） 

  运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。 

  就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。（只缺处理机这个资源） 

  阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。（缺除了处理机之外的其他资源） 

####   四个转换的过程 

###   僵尸进程  

  僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。  

###   孤儿进程  

  孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。  

##   内存 

###   内存分区 

  （高地址） 

  栈区：编译器自动分配，存放函数的参数值、局部变量的值，系统自动回收用完的内存 

  堆区：一般由程序员分配（malloc申请内存和free释放内存），如果不释放内存容易因引起内存泄漏 

  全局区（静态区）：静态变量和全局变量，内存被分配后直到程序结束之后才释放 

  常量区：（只读）存一些字符串常量、数组名等 

  代码区：（只读）存一些CPU执行的一些机器指令 

  （低地址）  

####   堆和栈的区别  

  栈：先进后出，生长方向向下，系统自动分配回收，高效快速；但有限制，数据不灵活。申请内存时，只要栈的剩余空间大于所申请的空间，系统将为程序员提供内存，否则报栈溢出。 

  堆：向上生长，需要程序员自己申请并指明大小。堆里分布的内存是不连续的。操作系统应该有记录空闲内存地址的链表，申请内存时遍历链表，找第一个空间大于申请空间的堆节点，分配内存… 

  把数据存到栈里比堆更快，因为系统会自动分配内存，堆需要自己分配和释放内存；另外访问堆的一个具体单元需要两次访问内存，一次获得指针，第二次才是真正的数据，而栈只要一次。 




###   缓冲区  

  又称缓存。在内存空间中预留一定的存储空间，用来缓冲输入输出的数据。 

  原因：CPU直接从磁盘读数据速度慢，增加读写次数对磁盘性能会有影响；使用缓冲区减小读写次数，CPU对缓冲区的操作速度也远大于磁盘的操作速度，增加计算机的运行速度。 

####   缓冲区溢出 

  计算机向缓冲区填充数据的时候超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。导致程序崩溃、趁这个机会获取程序乃至系统的控制权。 


###   虚拟内存  

  相当于从逻辑上扩充内存容量，在程序装入的时候，只把程序的一部分装入内存，就启动程序执行，执行过程中，访问的信息不在内存里时，操作系统将需要的部分调入内存，并把暂时不适用的内容换到外存上，腾出内存空间。让应用程序认为他用了一个比实际内存大得多的存储器。 

 

  虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。 


  多次性、对换性、虚拟性 



###   内存泄漏  

  程序没有释放已经不再使用的内存，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，因此这段内存一直被占用，无法释放，造成空间的浪费。  

####   怎么查  

1. 用封装的malloc函数，写代码时在malloc外封装一层，封装函数内打印一下malloc地址，free也是，然后运行时收集打印信息，可以用另外的脚本来分析内存的申请和释放是否一一对应。  

2. dmalloc库，第三个方案是valgrind工具 提一下常用的用法就行。  

​    

###   内存溢出  

  要求分配的内存超过了系统能给我的，系统不能满足需求。内存泄漏的堆积如果不及时处理最终会导致内存溢出  



###   基本分页储存管理方式  

  把主存空间划分为大小相等且固定的块，作为主存的基本单位，每个进程也以块为单位进行划分，进程执行时，以块为单位逐个申请主存中的块空间。用页表记录分散的内存分布情况。  

  **页表**：  

  用来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。  

  访问分页系统中内存数据需要两次内存访问，一次从内存中访问页表，找到实际物理地址，第二次根据得到的物理地址访问内存  

  页表储存在内存中。  

  逻辑空间->页表->物理空间  

  **快表机制：**  

  访问内存数据的时候先在快表里查询，如果查到了就可以直接读取相应的物理块号，如果每找到再访问页表，得到物理地址并访问，同时把该页表中的该映射项添加到块表中  

  **两级页表或多级页表**  

###   基本分段储存管理方式  

  分段管理：每个段内部连续内存分配，但段与段之间是离散的，因此会用到段表，记录每段在内存中的起始地址和该段长度。  

  段表可以放在内存或寄存器中。  

####   分页和分段的比较  

  页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；  

  段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制  

​    

  页的大小是固定的，由系统决定；  

  段的大小是不确定的，由用户决定  

​    

###   页面置换算法  

  为什么：  

  地址映射的过程中，如果页面中发现要访问的页面不在内存中，会产生缺页中断。此时操作系统必须在内存里选择一个页面把他移出内存，为即将调入的页面让出空间。选择淘汰哪一页的规则就是页面置换算法  

  分类：  

  **最佳置换算法（理想）**：将当前页面中在未来最长时间内不会被访问的页置换出去  

  **先进先出**：淘汰最早调入的页面  

  **最近最久未使用 LRU****：**每个页面有一个t来记录上次页面被访问直到现在，每次置换时置换t值最大的页面（用寄存器或栈实现）  

  **时钟算法clock**（也被称为最近未使用算法NRU）：页面设置访问为，将页面链接为一个环形列表，页面被访问的时候访问位设为1。页面置换的时候，如果当前指针的访问位为0，置换，否则将这个值置为0，循环直到遇到访问位为0的页面。  

  **改进型Clock算法**：在clock算法的基础上添加一个修改位，优先替换访问位和修改位都是0的页面，其次替换访问位为0修改位为1的页面。  

  **最少使用算法LFU**：设置寄存器记录页面被访问次数，每次置换当前访问次数最少的  

​    

##   用户态 内核态  

  内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。  

  用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。  

  最大的区别就是权限不同，在运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。  

###   为什么要有这两态：  

  需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络，CPU划分出**两个权限等级** -- 用户态和内核态。  

###   什么时候转换  

  **系统调用**：  

  用户进程主动发起的。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()就是执行一个创建新进程的系统调用  

  用户程序使用系统调用，系统调用会转换为内核态并调用操作系统  

  **异常**：  

  会从当前运行进程切换到处理次此异常的内核相关程序中  

  **外围设备的中断**：  

  所有程序都运行在用户态，但在从硬盘读取数据、或从键盘输入时，这些事情只有操作系统能做，程序需要向操作系统请求以程序的名义来执行这些操作。这个时候用户态程序切换到内核态。  

  

  用户接口程序（GUI或shell）  

  GUI，Graphical User Interface，图形用户界面，带有图形界面的操作系统；基于文本、命令行的叫shell  

  处于用户态中，位于用户态的最底层，允许用户运行其他程序  

  （而操作系统运行在内核态中  

​    

#   Linux  

##   Linux常用命令  

| 系统管理命令               | ::su                          | 切换账户                                 |
| -------------------------- | ----------------------------- | ---------------------------------------- |
| Ifconfig                   | 查看IP地址                    |                                          |
| Ping                       | 检查网络是否连接              |                                          |
| Kill                       | 杀死进程                      |                                          |
| Kill -9                    | 强制杀死                      |                                          |
|                            |                               |                                          |
| 系统资源查询命令           | ps                            | 查看进程                                 |
| ps -ef                     | 查看所有的进程                |                                          |
| netstat                    | 查看网络状况                  |                                          |
| netstat -apn               | 查看所有的端口                |                                          |
| df                         | 显示磁盘空间使用情况          |                                          |
| top                        | 查看进程资源占用              |                                          |
|                            |                               |                                          |
| 管道命令（同时执行）       | ps -ef \| grep                | 查看所有进程，通过管道找到相应的进程包名 |
| chmod                      | 赋权命令                      |                                          |
|                            |                               |                                          |
| 目录操作命令               | cd                            | 进入目录里面                             |
| cd /                       | 根目录                        |                                          |
| pwd                        | 当前目录                      |                                          |
| mkdir                      | 创建目录                      |                                          |
| rmdir                      | 删除目录                      |                                          |
| ls                         | 查看现有的目录                |                                          |
|                            |                               |                                          |
| 文件编辑就命令             | vi + 文件                     | 编辑文件                                 |
| cat a.txt                  | 查看文件，显示内容            |                                          |
| rm -rf                     | 强制删除                      |                                          |
| find / -name .txt          | 在根目录下面查找txt文件       |                                          |
| cp -ai a.txt test          | 复制a.txt到test目录下         |                                          |
| tail -f pin.log            | 显示pin.log文件末尾内容       |                                          |
| find                       | 查找                          |                                          |
| grep                       | 文本搜索                      |                                          |
| touch                      | 如果没有就创建，有就不理它    |                                          |
|                            |                               |                                          |
| 文件解压压缩命令           | tar -czvf test.tar.gz.test    | 压缩 将文件压缩成.test.tar.gz            |
| tar -xzvf test.tar.gz.test | 解压 将文件解压成.test.tar.gz |                                          |

​    

##   linux和windows的区别，linux相比windows有什么优势  

  Linux是一个以开发者为中心的操作系统，而windows是以消费者为中心的操作系统 

  Linux是免费的、开源的，更容易得到他的源代码，也就更容易实现个性化定制 

  Linux的命令行功能强大，windows的命令行没这么厉害… 

  Linux基于网络，只要有相应权限，就能远程操控相应的服务器 

  ….. 

  | 是什么： 

  管道符，就是把符号左边命令本来要打印到终端上的信息当做右边命令的操作对象 

 

  Linux命令 如何杀死占用指定端口的进程  

  先查端口对应的进程，然后kill进程号  

  （ss、netstat查进程  



  grep怎么输出文本中包含某个关键字的行，不包含的呢 

  grep -v xxx输出不包含的 

 

  装软件 

  系统是debian的，apt-get 

  其他方式还有yum、rpm 



  du，df的区别 

  VI 显示所有行的行号：vi set number  

  找到共用80端口的线程  

  linux基本指令 awk、find、grep  

  shell脚本：统计一个文件中重复的行和重复次数  

  linux 如何将文件从一台服务器转移到另一台服务器  

  如何查找出现频率最高的100个ip地址  

  sh .sh source .sh ./a.sh区别  

​    

#   C++

##   Static/const  

  static，静态：1. 将函数或变量对其他源文件隐藏，只能被本地模块引用，即局部有效。2. 静态局部变量，在函数体内用static修饰变量，将本来要被存在栈中的局部变量保存在了静态空间中，函数退出时他仍然存在，延长了该变量的生命周期。  

  const，只读：被const修饰的量为常量，表示禁止这个量被修改；同时向阅读代码的人传递信息表示：这一块的内容不要区改他，只读的，同样也能保护代码。  

​    

##   字节序  

  在存储器中储存字节的顺序，分大端和小端两种。大端：高位字节在前，低位字节在后，是人类的读写方式；小端反过来，是计算机的读写方式  

##   Strcpy(destination, sourse)  

  从sourse字符串的第一位开始往后赋值，直到遇到”\0”  

  Printf %s也是打印到\0停止  

​    

##   Sizeof  

  内存地址的大小和指针指向无关，只和操作系统位数有关。  

  函数传参不能传数组，编译器会自动把数组转换成指针形式  

​    

##   Volatile  

  程序读取变量时一般是向寄存器里读值而不是在内存读值（编译器的优化），Volatile告诉程序这个值随时都能变化，需要保证每次执行的时候都从内存里取值。  

​    

  数组指针  

  a+1数组下一个值首地址，&a表示数组地址，&a+1为下一个数组首地址  

​    

##   运算符优先级  

  */+-位运算  

​    

##   函数宏  

  \#define MYPOW(x) ((x)*(x))  

  宏名要大写，每个变量都要加括号  

##   内存对齐  

##   隐式转换  

  …  

​    

#   数据库  

  事务的特性：原子性、一致性、隔离性、持久性。  

  联合主键：设置多个字段同时为主键（PRIMARY KEY(Name, Age)）  

  复合主键：多个主键联合形成一个主键组合。（成绩表中的学号、课程标号）  

  mysql怎么优化  

  数据库的备份是如何实现的 

  mysql建立索引 CREATE INDEX index_name ON table_name (column_list) CREATE INDEX idx_c4 ON t(c4);  

  数据库查询10-20行内容：select * from stu limit 10, 10;  

  查找135开头的电话：select * from table where tel like '135%';  

  left join, right join和inner join的影响性能的因素。  

  sql：三表查询、两表查询  

  …  

#   测试相关  

##   测试理论  

###   白盒测试  

  白盒测试也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，  

  常见的白盒测试的方法有：语句覆盖，条件覆盖，判定覆盖，条件组合覆盖，基本路径覆盖等等。  

  优点：可以检测代码的每条分支和路径；可以揭示隐藏在代码中的错误；对代码的测试比较彻底。  

  缺点：耗费比较大；不能检测到代码中遗漏的逻辑；不能直接验证需求的正确性  

###   黑盒测试  

  黑盒测试也称功能测试或数据驱动测试，它不看代码内部的逻辑，只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。  

  常见方法有等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。  

  优点：容易实施，不需要关注内部实现；贴近用户需求。  

  缺点：覆盖率比较低，因为不知道内部逻辑  

###   单元测试  

  单元测试：软件组成单元进行测试，其目的是检验软件基本组成单位的正确性，通常情况下是白盒的，能够尽早的发现错误，降低修改成本。  

​    

###   性能测试关注啥  

  指标：响应时间（RT）、每秒能完成的响应数（TPS）、CPU利用率、内存占用、网络（带宽使用率）、手机app的话还考虑耗电量……  

  考虑负载加大时，各项指标如何变化，联网的考虑各种不同的网络环境（正常网、超快网、网速慢、断网）时指标的变化  

​    

###   压力测试关注啥  

​    

###   并发用户数和在线用户数的区别  

  在线用户数：用户同时在一定时间段的在线数量  

  并发用户数：某一时刻同时向服务器发送请求的用户数  

  （在线用户只要在线就好了，并发用户计算的是和服务器有交流的用户，一般比例5%-20%）  

​    

##   测试的阶段  

  测试应该尽早进行。越早就可以花越少的消耗得到越大的回报。  

##   单元测试  

  单元测试是对软件组成单元进行测试，其目的是检验软件基本组成单位的正确性，测试的对象是软件设计的最小单位：函数、或者类。  

  项目中的测试类就是测试接口类的，属于单元测试，一般由开发人员测试。  

##   集成测试  

  集成测试也称综合测试、组装测试、联合测试，将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。其主要目的是检查软件单位之间的接口是否正确，集成测试的对象是已经经过单元测试的模块。  

##   系统测试  

  系统测试是对整个系统的测试，将硬件、软件、操作人员看作一个整体，检验它是否有不符合系统说明书的地方，主要包括功能测试、界面测试、可靠性测试、易用性测试、性能测试。 功能测试主要针对包括功能可用性、功能实现程度（功能流程&业务流程、数据处理&业务数据处理）方面测试。在集成测试之后。  

###   集成测试和系统测试之间的比较：   

  1、测试内容：集成测试是测试各个单元模块之间的接口，系统测试是测试整个系统的功能和性能；   

  2、测试角度：集成测试偏重于技术的角度进行测试，系统测试是偏重于业务的角度进行测试。  

​    

##   验收测试   

  也称交付测试，是针对用户需求、业务流程进行的正式的测试，以确定系统是否满足验收标准，由用户、客户或其他授权机构决定是否接受系统。  

​    

  验收测试包括alpha测试和beta测试，alpha测试是由开发者进行的软件测试，beta测试是由用户在脱离开发环境下进行的软件测试。  

​    

##   回归测试  

##   测试的类型  

  功能测试：关注功能正常（包含兼容性测试），除了下面分类都测；  

  性能测试：关注（比如前端性能、后端性能）；  

  安全测试：关注传输、存储等安全；  

  特性测试：特性指平台差异(即部分兼容性测试)，如PC端鼠标，键盘操作特性(Tab键等)；如手机触屏操作，横竖屏，中断恢复(来电)等  

​    

##   QPS（每秒查询率）  

  QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准  

  用来衡量服务器的机器性能。  

###   QPS和TPS的区别  

  TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。  

  是软件测试结果的测量单位。  

###   系统吞吐量  

​    

##   瀑布模型和敏捷模型  

  瀑布模型：  

  把软件开发模型分为好几个阶段，包括软件计划、需求分析、设计、实现、软件测试、软件运行维护。  

  具有一种比较明显的分层，每一阶段的结果文档会作为下一阶段的输入，强调文档，整个周期完成的差不多了才能看到结果；  

  没有迭代和反馈，只能一步一步来，流程没有回头路。不能适应客户不断变化的需求，后期需要改动时成本也比较大  

  测试比较晚，基本上是在软件完成之后进行的测试  

​    

  敏捷开发：  

  按一个短的迭代周期工作，强调“快”，每次迭代交付一些成果，（或者说先做出一个不完美但能实现一定的功能的版本）；让客户参与进来，有新需求就，快速响应变化，迭代产生新版本，缩短软件版本的周期。  

  强调开发软件而不是文档。  

  特点：让客户参与进来，客户需求的变动和软件有些不符合需求的地方可以第一时间进行了解和改动； 缩短版本周期； 每隔一段时间（一个迭代周期），团队可以在工作方面进行反省和改进，调整自己的行为； 强调开发软件而不是文档，提高编程人员的积极性。  

​    

  敏捷测试：  

  以用户需求为中心，在每一个迭代周期都需要进行测试，  

  基于自动化测试->速度快、敏捷  

  更强调测试的速度和适应性，侧重计划的不断调整以适应需求的变化  

  强调面对面的沟通、协作，强调团队的责任，不太关注对缺陷的记录与跟踪。缺陷修复的成本也较低  

​    

##   V模型和W模型  

  V模型：把测试过程作为在需求分析、系统设计及编码之后的一个阶段，忽视了测试对需求分析，系统设计的验证，需求的满足情况一直到后期的验收测试才被验证。（应该比较多包括系统测试和验收测试）  

  W模型：测试的活动与软件开发同步进行，测试的对象不仅仅是程序，还包括需求和设计。因为在需求阶段测试就已经介入了，后面每一阶段的开发都需要经过测试，能够尽早发现软件的缺陷，降低debug的成本  



##   Web和app测试的区别  

1. 首先是web和app的区别：web是b/s架构的，基于浏览器；app是c/s架构的，必须要有客户端。Web测试中只要更新了服务器，客户端就会同步更新，保证每个用户用的客户端一样；app就不能保证完全一致，因为app客户端需要用户主动更新，如果app测试中修改了服务器，就意味着客户端用户使用的所有核心版本都要进行回归测试  

2. 性能方面：web主要看响应速度；app还看电量、流量、CPU、内存…  

3. 兼容方面：web基于浏览器，主要看电脑硬件、电脑系统；app依赖于手机或平板，关注的系统主要是安卓和ios，还要关心分辨率、屏幕尺寸  

4. App比web测试多一些专项测试：弱网测试，安装、卸载、更新，界面操作、触摸手势等  

 

##   软件测试流程  

  需求分析；制定测试计划（在研发计划制定时就应该定好测试计划）；设计测试用例；执行测试（包括单元测试、集成测试、系统测试、回归测试、验收测试）；测试评估（出报告，确认是否可以上线）；面向用户  

 

##   测试一款产品/一个功能  

  （角度） 

  功能： 

  性能：响应速度、CPU占用，联网的话考虑多用户并发/弱网环境，app的话考虑耗电量 

  易用性 

  兼容性：多平台/多系统/多版本 

  安全：用户名密码有没有保存功能，数据往服务器传是不是加密的，有没有防止一些脚本或者SQL注入攻击 

  UI：符合大众期望，有无错别字，排版和颜色搭配  

  稳定性：压力测试、极端条件测试 

  （查看产品的使用说明书）  



  软件质量模型的6大特性：  

  功能性，可靠性，易用性，效率，维护性，可移植性  

 

##   案例/情景题  

###   以百度搜索为例，设计测试方案  

  从以下几个角度进行测试  

  **功能测试：**  

  输入搜索信息，点击搜索按钮是否能获取搜索结果，跳到结果界面；  

  搜索结果界面弹出的信息是不是符合我输入的信息  

  没有输入信息，按搜索看会有什么结果  

  对输入框能输入的最大字符数进行边界测试，（假设限制是30个字符），那么分别输入20，30，31个字符的文本进行测试，测试超出输入限制会出现的结果  

  测试输入敏感词时的搜索结果  

  输入不同国家语言的搜索结果  

  查询不到搜索结果的情况显示的结果  

  从搜索结果界面返回的按钮能不能正常返回  

  点击百度的标签能不能跳到相关的热搜界面  

  测试百度的图片搜索能不能正常使用  

  图片拖曳和上传的功能是否均能实现，粘贴图片网址能不能用  

  如果粘贴的图片网址不存在是否能给出正确的提示反馈  

  输入特别大的图会发生什么现象  

  **性能测试：**  

  测试搜索时的响应时间能否符合需求  

  网速慢的条件下还能不能正常搜索  

  多用户同时访问，或者一个时间点访问量突然增大的情况，对这些特殊情况进行模拟，测试还能不能进行正常搜索  

  **易用性测试：**  

  使用操作是否简单，是不是输入查询信息之后点击搜索按钮就行了；  

  在输入框输入搜索词的过程中下拉框能否弹出相关的联想搜索（你可能要搜）  

  输入框有没有保存最近搜索的信息的记录  

  除了点击搜索按钮进行搜索，测试按回车进行检索的功能  

  **兼容性测试：**  

  多种系统下的多种不同的浏览器下是否能正常显示、正常使用；  

  在不同的手机浏览器中打开是否能正常显示、正常使用；  

  各种语言平台下是否都能正常使用  

  **安全性测试：**  

  能不能防止搜索时对数据库的恶意攻击的情况，如SQL注入  

  **UI**：**  

  界面设计是否简介，是否符合用户审美  

  图标能不能正常显示，界面有无错别字  

 

###   测试用例：上传文件  

###   测试用例：微信扫码点餐  

###   如何测试网站的高并发性（不是很会…）  

  测试多用户同时访问，访问量的缓慢增加/迅速增加。。。  

  大量相同类型访问，大量不同类型的访问  

  服务器角度，能够承受多大的压力（？），客户端角度，数据能否成功得到需要的信息，响应时间怎么样  

  实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息 

  一方面保证数据不丢失、一方面保证性能  



###   测试一个前端页面，button按钮不好使，原因，不获取源码的前提下，如何解决（提示接口测试）  

  因为这是个前端界面，可以按F12打开开发者工具，在network里按钮点击时请求有没有发出去，看状态码，有没有生成新文件之类的，确定是不是连接的问题。  

  postman模拟发包过去测试也行。  

​    

##   selenium流程、获取元素方法  

  先import，然后webdriver模拟打开一个浏览器（初始化），获取特定的网址，然后通过获取元素模拟鼠标点击页面上的按钮（或者其他动作，比如在特定的文本框输入特定的内容），（最后quit()一下）  

  获取元素方法：xpath，css选择器，文本内容…..等等，比如find_element_by_xpath、find_element_by_css_selector、find_element_by_link_text  

 

##   其他  

  app登录和网页登录的区别  

  估计美团外卖一天内的全国订单量 

  淘宝页面价格显示不出来，该怎么测  

  如果有一部分用户反馈APP的视频加载不出来，你会从哪里方面去定位问题  

  在一个产品的周期中，你会怎么安排测试工作



## 2020-06-25

### String StringBuilder StringBuffer区别

- 都是final类,不允许被继承
- StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且**不产生新的未使用对象**。
- StringBuilder 类在 Java 5 中被提出， 不是线程安全的，但是有速度优势，常用于单线程
- StringBuffer 类，线程安全，常用于多线程，很多方法带有synchronized关键字

### RuntimeException有哪些

- 算数错误
- 下标越界
- 空指针异常
- 类找不到
- 等等

### hashCode与equals

- 都是用来对比两个对象是否相等一致
- equal（）里一般比较的比较全面比较复杂，这样效率就比较低
- 利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高
- hashCode()并不是完全可靠，因为不同的对象可能哈希值相同
- Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址
- 对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，**所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！**

### 怎么实现序列化与反序列化

序列化之后对象可以通过网络传输，可被写到文件中

序列化就是将对象转换成二进制序列，反序列化则是将二进制序列转换成对象

1、序列化

- 实现 Serializable 接口

- JDK 类库中序列化 API

    使用到JDK中关键类 **ObjectOutputStream**(对象输出流) 和**ObjectInputStream**(对象输入流)

    ObjectOutputStream 类中：通过使用 writeObject(Object object) 方法，将对象以二进制格式进行写入。

    ObjectInputStream 类中：通过使用 readObject（）方法，从输入流中读取二进制流，转换成对象

### 隔离级别，msyql怎么解决可重复读

- 读提交：其他事务提交之后的数据，我可以读到（不可重复读）
- 读未提交：脏读，其他事物没提交的数据，我可以读到
- 可重复读（mysql默认）：确保同一事务的多个实例在并发读取数据时，会看到同样的数据行（存在幻读现象），InnoDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
- 串行化



多版本并发控制：保存一个版本号，查询时InnoDb只查找版本早于（包含等于）当前版本的数据行。

MVCC只在 Read Committed 和 Repeatable Read两个隔离级别下工作

### innodb与myisam区别

- InnoDB支持事务，外键，MyISAM不支持
- **InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的**
- MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针
- **InnoDB不保存表的具体行数，执行select count(\*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）**
- InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有



### 最左前缀

### 内连接 左连接 右连接

### 算法题：

给一整数数组, 用当前元素之后数组中的最大元素来替换当前元素(右侧的最大元素). 因为最后一个元素的右边没有元素了, 所以用 -1 来替换这个值. 举个例子, 如果数组为 [16,17,4,3,5,2], 那么它就需要修改为 [17,5,5,5,2,-1]。 要求：你需要在原地实现（不允许创建新的数组或几何对象）

### volatile

告诉编译器，不要去优化这个值，因为我这个值是会变的，每次读的时候去内存里面去读，不要去缓存里面读

### JDK动态代理原理

1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法
2.创建被代理的类以及接口
3.通过Proxy的静态方法newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理
4.通过代理调用方法

### 堆与栈区别

### 创建线程方式

1、通过继承Thread并且重写其run()，run方法中即线程执行任务。创建后的子类通过调用 start() 方法即可执行线程方法。**多个线程间无法共享线程类的实例变量。（需要创建不同Thread对象，自然不共享）**

2、实现Runnable接口，并重写该接口的 run() 方法，此run方法是线程执行体。接着创建 Runnable实现类的对象，作为创建Thread对象的参数target，**此Thread对象才是真正的线程对象**。**通过实现Runnable接口的线程类，是互相共享资源的。**

3、通过Callable和Future接口创建线程

### http 状态码，请求头

### 联合索引例子，where条件中name = fun('A') 和 fun(name)='A'性能区别

### B树和B+树

# 面向对象

- 封装
- 继承
- 多态

面向[对象](https://baike.baidu.com/item/对象)是在[结构化设计方法](https://baike.baidu.com/item/结构化设计方法)出现很多问题的情况下应运而生的。

求解问题的基本策略是**从功能的角度**审视问题域。

- 应用程序模块化
- 每个模块完成某一项具体的功能
- 在每个功能模块中，用[数据结构](https://baike.baidu.com/item/数据结构)描述待处理数据的组织形式，用[算法](https://baike.baidu.com/item/算法)描述具体的操作过程

## 封装



## 继承

- [继承](https://baike.baidu.com/item/继承/20267560)简单地说就是一种层次模型，这种层次模型能够被重用。

- 层次结构的上层具有通用性，但是下层结构则具有特殊性。

- 在继承的过程中类则可以从最顶层的部分继承一些方法和变量。
- 类除了可以继承以外同时还能够进行修改或者添加。
- 继承是从一般演绎到特殊的过程



## 多态

多态是指不同事物具有不同表现形式的能力。[多态](https://baike.baidu.com/item/多态/2282489)机制使具有不同内部结构的对象可以共享相同的外部接口，通过这种方式减少代码的复杂度。









