# volatile

轻量级的 `synchronized`，不会引起上下文的切换

## 原理

（1）将当前处理器中改变量的缓存写到内存

（2）使其他处理器缓存了该内存地址的数据无效

> 嗅探技术：处理器可以保证内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致
>
> 简单讲，这个技术可以检测到，其他 CPU 改了内存的数据，那好，我把我这个数据跟内存的数据同步一下

# synchronized

重量级锁，1.6 版本优化了

## synchronized 锁了什么？

（1）普通方法，锁是当前实例对象

（2）静态方法，当前类的 Class 对象

（3）同步方法快，括号里的那个对象

## Monitor 对象

基于 Monitor 对象实现方法同步和代码块同步

代码块同步：monitorenter 指令和 monitorexit 指令（分别插到了代码块的开始位置、方法结束位置和异常处）

## synchronized 用的锁在哪

在 Java 对象头里面，`Mark Word` 里

## 锁的升级与对比

从低到高：无锁、偏向锁、轻量级锁、重量级锁

特点：

（1）随着竞争的情况升级

（2）只升不降（原因：提高获得锁和释放锁的效率）

### 偏向锁

HotSpot 作者发现，锁不仅会被竞争，而且拿到锁的总是那几个线程。基于这个，引入了偏向锁

一个线程拿到锁之后，会在对象头和栈帧的锁记录里面存储锁偏向的线程 ID，以后再来，先查查对象头里面有没有指向当前线程的偏向锁，有的话直接拿到锁，没有的话测试对象头里面偏向锁的 ID 是否被设置了，有的话，把偏向锁指向自己，如果没有，使用 CAS 竞争锁

> CAS(compare and swap)
>
> CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)
>
> CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”

**如何撤销锁**

其他线程尝试竞争的时候，拿到锁的线程才会释放。

### 轻量级锁





| 锁       | 优点 | 缺点 | 适用场景 |
| -------- | ---- | ---- | -------- |
| 偏向锁   |      |      |          |
| 轻量级锁 |      |      |          |
| 重量级锁 |      |      |          |

