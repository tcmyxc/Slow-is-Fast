# 尚硅谷MySQL学习笔记

## 存储引擎

存储引擎就是指表的类型。

功能：接收上层传下来的指令，然后对表中的数据进行提取或者写入操作。

查看引擎：`show engines`

```tex
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
```

`XA`：是否支持分布式事务

创建表的时候可以指定存储引擎，如下：

```mysql
create table emp(id int) engine=InnoDB;
```

表创建好之后可以修改存储引擎（引擎名可以全部小写）：

```mysql
alter table emp engine=myisam;
```

### InnoDB：具备外键支持功能的事务存储引擎

- 5.5版本之后的默认存储引擎
- MySQL的默认`事务型引擎`，可以处理大量的短期（short-lived）事务，可以保证事务的完整提交和回滚
- 如果有大量的更新、删除操作，优先选择 InnoDB
- 数据文件结构：
	- `表名.frm` 存储表结构（8.0 时合并在`表名.ibd` 中）
	- `表名.ibd` 存储数据和索引
- 为处理巨大数据量的最大性能设计
- 相比 MyISAM，`InnoDB 写的效率差一些`，并且会占用更多的磁盘空间来保存数据和索引
- MyISAM 只缓存索引，不缓存真实数据；InnoDB 索引和真实数据都缓存，并且对内存要求较高，内存大小对性能有决定性的影响

### MyISAM：主要的非事务处理存储引擎

处理数据量比较小的

- `5.5版本之前的默认存储引擎`，提供大量特性，如全文索引、压缩、空间函数（GIS）等
- 不支持事务、行锁、外键，崩溃后无法安全恢复
- 优势是`访问的速度快`，适合对事务完整性没有要求或者以插入、查询为主的应用
- 针对数据统计有额外的常数存储。因此 `count(*)` 的查询的效率很高
- 数据文件结构
	- `表名.frm` 存储表结构
	- `表名.MYD` 存储数据（MYData）
	- `表名.MYI` 存储索引（MYIndex）
- 应用场景：只读应用或者以读为主的应用

<br/>

| 对比项 | MyISAM                                             | InnoDB                                           |
| ------ | -------------------------------------------------- | ------------------------------------------------ |
| 外键   | 不支持                                             | 支持                                             |
| 事务   | 不支持                                             | 支持                                             |
| 行表锁 | 表锁，即使操作一条记录也会锁住整个表，不适合高并发 | 行锁，操作时只锁某一行，不影响其他行，适合高并发 |
| 缓存   | 只缓存索引，不缓存真实数据                         | 索引和真实数据都缓存                             |
| 关注点 | 性能：节省资源、消耗少、简单事务                   | 事务：并发写、事务、更大资源                     |

## 索引

### 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则`通过索引查找`相关数据，如果不符合则需要`全表扫描`，即需要一条一条地查找记录，直到找到与条件符合的记录。

![image-20220616141351236](images/image-20220616141351236-16630739426831.png)

如上图所示，数据库没有索引的情况下，数据`分布在硬盘不同的位置上面`，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果`数据顺序摆放`，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，`依旧非常耗时`。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col 2 = 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有`上千万条数据`，就意味着要做`很多很多次硬盘I/0`才能找到。现在要查找 Col 2 = 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）

假如给数据使用 `二叉树` 这样的数据结构进行存储，如下图所示

![image-20220616142723266](images/image-20220616142723266-16630741268193.png)

对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 `二叉搜索树`。二叉搜索树的每个结点存储的是 `(K, V) 结构`，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：`(34, 0x07)`。现在对 Col 2 添加了索引，这时再去查找 Col 2 = 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 > 34; 继续右侧数据，读 89 到内存，89==89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 `查找两次` 就可以定位到记录的地址，查询速度就提高了。

这就是我们为什么要建索引，目的就是为了 `减少磁盘I/O的次数`，加快查询速率。

### 索引及其优缺点

#### 索引概述

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。

**索引的本质**：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 `高级查找算法` 。

`索引是在存储引擎中实现的`，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 `最大索引数`和 `最大索引长度`。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。

#### 优点

（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 **数据库的IO成本** ，这也是创建索引最主要的原因。

（2）通过创建唯一索引，可以保证数据库表中每一行 **数据的唯一性** 。

（3）在实现数据的 参考完整性方面，可以 **加速表和表之间的连接** 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。

（4）在使用分组和排序子句进行数据查询时，可以显著 **减少查询中分组和排序的时间**，降低了CPU的消耗。

#### 缺点

增加索引也有许多不利的方面，主要表现在如下几个方面：

（1）创建索引和维护索引要 **耗费时间** ，并 且随着数据量的增加，所耗费的时间也会增加。

（2）索引需要占 **磁盘空间** ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。

（3）虽然索引大大提高了查询速度，同时却会 **降低更新表的速度** 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

> 提示：
>
> 索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。

